<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Line Graph: Slope & Y-Intercept</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 40px; background: #f8f9fa; }
        .container { max-width: 600px; margin: auto; background: #fff; padding: 24px; border-radius: 12px; box-shadow: 0 2px 8px #0001; }
        label { display: block; margin-top: 16px; font-weight: bold; }
        input[type=number] { width: 100px; margin-left: 8px; }
        canvas { display: block; margin: 32px auto 0 auto; background: #fff; border: 1px solid #ccc; border-radius: 8px; }
        /* 90s hacker terminal styles */
        #hacker-terminal {
            display: none;
            position: fixed;
            top: 0; left: 0; width: 100vw; height: 100vh;
            background: #000;
            color: #00ff00;
            font-family: 'Courier New', Courier, monospace;
            font-size: 1.1em;
            z-index: 9999;
            padding: 32px;
            box-sizing: border-box;
            opacity: 0.97;
        }
        #hacker-terminal .close-btn {
            position: absolute;
            top: 16px; right: 32px;
            color: #0f0;
            background: none;
            border: 2px solid #0f0;
            border-radius: 4px;
            font-size: 1.2em;
            padding: 4px 12px;
            cursor: pointer;
        }
        #hacker-terminal pre {
            margin: 0;
            white-space: pre-wrap;
            word-break: break-all;
        }
        @keyframes blink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0; }
        }
        #hacker-terminal .cursor {
            display: inline-block;
            width: 10px;
            background: #00ff00;
            animation: blink 1s step-end infinite;
        }
    </style>
</head>
<body>
    <div class="container">
        <h2>Graph a Line: y = mx + b</h2>
        <label>Slope (m): <input type="number" id="slope" value="1" step="0.1"></label>
        <label>Y-Intercept (b): <input type="number" id="yintercept" value="0" step="0.1"></label>
        <canvas id="graph" width="500" height="400"></canvas>
    </div>
    <div id="hacker-terminal">
        <button class="close-btn" onclick="hideTerminal()">X</button>
        <pre id="terminal-content"></pre><span class="cursor"></span>
    </div>
    <script>
        // Graph logic
        const slopeInput = document.getElementById('slope');
        const yintInput = document.getElementById('yintercept');
        const canvas = document.getElementById('graph');
        const ctx = canvas.getContext('2d');
        // Infinite draggable canvas logic
        let panX = 0; // in graph units
        let panY = 0; // in graph units
        let dragging = false;
        let lastMouse = {x: 0, y: 0};
        let scale = 25; // px per graph unit
        function drawGraph() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            const m = parseFloat(slopeInput.value);
            const b = parseFloat(yintInput.value);
            // Center of canvas in graph units
            const centerX = panX;
            const centerY = panY;
            // Functions to convert between graph and canvas coordinates
            function toCanvasX(x) { return canvas.width/2 + (x - centerX) * scale; }
            function toCanvasY(y) { return canvas.height/2 - (y - centerY) * scale; }
            function toGraphX(px) { return centerX + (px - canvas.width/2) / scale; }
            function toGraphY(py) { return centerY - (py - canvas.height/2) / scale; }

            // Draw grid lines
            ctx.strokeStyle = '#eee';
            ctx.lineWidth = 1;
            let gridStep = 1;
            let xStart = Math.floor(centerX - canvas.width/(2*scale)) - 1;
            let xEnd = Math.ceil(centerX + canvas.width/(2*scale)) + 1;
            let yStart = Math.floor(centerY - canvas.height/(2*scale)) - 1;
            let yEnd = Math.ceil(centerY + canvas.height/(2*scale)) + 1;
            for (let gx = xStart; gx <= xEnd; gx++) {
                let px = toCanvasX(gx);
                ctx.beginPath(); ctx.moveTo(px, 0); ctx.lineTo(px, canvas.height); ctx.stroke();
            }
            for (let gy = yStart; gy <= yEnd; gy++) {
                let py = toCanvasY(gy);
                ctx.beginPath(); ctx.moveTo(0, py); ctx.lineTo(canvas.width, py); ctx.stroke();
            }
            // Draw axes
            ctx.strokeStyle = '#888';
            ctx.lineWidth = 2;
            // y-axis
            let yAxisX = toCanvasX(0);
            ctx.beginPath(); ctx.moveTo(yAxisX, 0); ctx.lineTo(yAxisX, canvas.height); ctx.stroke();
            // x-axis
            let xAxisY = toCanvasY(0);
            ctx.beginPath(); ctx.moveTo(0, xAxisY); ctx.lineTo(canvas.width, xAxisY); ctx.stroke();

            // Draw the line y = mx + b
            ctx.strokeStyle = '#0074D9'; ctx.lineWidth = 2; ctx.beginPath(); let first = true;
            for (let px = 0; px <= canvas.width; px++) {
                let x = toGraphX(px);
                let y = m * x + b;
                let py = toCanvasY(y);
                if (first) { ctx.moveTo(px, py); first = false; } else { ctx.lineTo(px, py); }
            }
            ctx.stroke();

            // Draw ticks and labels
            ctx.fillStyle = '#444'; ctx.font = '12px Arial';
            for (let gx = xStart; gx <= xEnd; gx++) {
                let px = toCanvasX(gx);
                ctx.beginPath(); ctx.moveTo(px, xAxisY - 5); ctx.lineTo(px, xAxisY + 5); ctx.stroke();
                if (gx !== 0) ctx.fillText(gx, px-8, xAxisY + 18);
            }
            for (let gy = yStart; gy <= yEnd; gy++) {
                let py = toCanvasY(gy);
                ctx.beginPath(); ctx.moveTo(yAxisX - 5, py); ctx.lineTo(yAxisX + 5, py); ctx.stroke();
                if (gy !== 0) ctx.fillText(gy, yAxisX + 8, py+4);
            }
        }

        slopeInput.addEventListener('input', drawGraph);
        yintInput.addEventListener('input', drawGraph);
        drawGraph();

        // Dragging logic
        canvas.addEventListener('mousedown', function(e) {
            dragging = true;
            lastMouse.x = e.clientX;
            lastMouse.y = e.clientY;
        });
        window.addEventListener('mousemove', function(e) {
            if (!dragging) return;
            let dx = e.clientX - lastMouse.x;
            let dy = e.clientY - lastMouse.y;
            panX -= dx / scale;
            panY += dy / scale;
            lastMouse.x = e.clientX;
            lastMouse.y = e.clientY;
            drawGraph();
        });
        window.addEventListener('mouseup', function() { dragging = false; });

        // Optional: scroll to zoom
        canvas.addEventListener('wheel', function(e) {
            e.preventDefault();
            let mouseX = e.offsetX;
            let mouseY = e.offsetY;
            let graphX = panX + (mouseX - canvas.width/2) / scale;
            let graphY = panY - (mouseY - canvas.height/2) / scale;
            let zoom = e.deltaY < 0 ? 1.1 : 0.9;
            scale *= zoom;
            // Keep the point under the mouse stationary
            panX = graphX - (mouseX - canvas.width/2) / scale;
            panY = graphY + (mouseY - canvas.height/2) / scale;
            drawGraph();
        }, { passive: false });

        // 90s hacker terminal logic
        const terminal = document.getElementById('hacker-terminal');
        const terminalContent = document.getElementById('terminal-content');
        let terminalActive = false;
        let terminalLines = [
            'ACCESS GRANTED...\n',
            'Initializing mainframe...\n',
            'Bypassing firewall...\n',
            'Downloading secret files...\n',
            '>>> _\n'
        ];
        function showTerminal() {
            terminal.style.display = 'block';
            terminalActive = true;
            terminalContent.textContent = '';
            typeTerminal(0, 0);
        }
        function hideTerminal() {
            terminal.style.display = 'none';
            terminalActive = false;
        }
        function typeTerminal(lineIdx, charIdx) {
            if (!terminalActive) return;
            if (lineIdx >= terminalLines.length) return;
            let line = terminalLines[lineIdx];
            if (charIdx < line.length) {
                terminalContent.textContent += line[charIdx];
                setTimeout(() => typeTerminal(lineIdx, charIdx + 1), 18 + Math.random()*40);
            } else {
                setTimeout(() => typeTerminal(lineIdx + 1, 0), 200);
            }
        }
        document.addEventListener('keydown', function(e) {
            if (e.key === 'g' && !terminalActive) {
                showTerminal();
            } else if (e.key === 'Escape' && terminalActive) {
                hideTerminal();
            }
        });
        window.hideTerminal = hideTerminal;
    </script>
</body>
</html>
